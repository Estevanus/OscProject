import bge
import sys
import var
import mainscript
import checker
import datetime
from mathutils import Vector, Euler
from math import radians, degrees, hypot, sin
import HUD
from weapons import rTimeLeft, setWeapons, weapons
import datetime

Look = 'Look'
interceptPoint = 'interceptPoint'

nope = bge.logic.KX_INPUT_NONE
jaktif = bge.logic.KX_INPUT_JUST_ACTIVATED
aktif = bge.logic.KX_INPUT_ACTIVE
lepas = bge.logic.KX_INPUT_JUST_RELEASED

keyboard = bge.logic.keyboard
keyev = keyboard.events
mouse = bge.logic.mouse
moev = mouse.events
'''
keymap = var.globalDict['control']['control_tank']

changeCamera = keyev[bge.events.CKEY]

n0 = keyev[bge.events.ZEROKEY]
n1 = keyev[bge.events.ONEKEY]
n2 = keyev[bge.events.TWOKEY]
n3 = keyev[bge.events.THREEKEY]
n4 = keyev[bge.events.FOURKEY]
n5 = keyev[bge.events.FIVEKEY]
n6 = keyev[bge.events.SIXKEY]
n7 = keyev[bge.events.SEVENKEY]
n8 = keyev[bge.events.EIGHTKEY]
n9 = keyev[bge.events.NINEKEY]

def deltaTimeToSeconds(dt):
	s = float(dt.days) * 24 * 60 * 60 + float(dt.seconds) + (dt.microseconds / 1000000)
	return s
	
def rTimeLeft(jarak, reloadTime):
	s = deltaTimeToSeconds(jarak)
	return reloadTime - s
'''

# ----------------------------------------- Comander Section -----------------------------------------
class KX_Commander(bge.types.KX_GameObject):
	def __init__(self):
		self.useBy = 'bot'
		self.team = 1
			
	useBy = 'bot'
	team = 1
	
	def run(self):
		if self.useBy == 'bot':
			if self.team == 1:
				if var.botCommanderTeamA != None:
					var.botCommanderTeamA.run()
			if self.team == 2:
				if var.botCommanderTeamB != None:
					var.botCommanderTeamB.run()
		else:
			pass
			#script for player if player reach a commander rank already
			
#commanderControllerObject
def runCommanderController(cont):
	cont.owner.run()
# ----------------------------------------------------------------------------------------------------

def setCamPos(cont):
	var.player.setCamPos()
	print("campos has been set")
	for i in cont.actuators:
		cont.activate(i)

def event(keymap, keyev, moev, e):
	key = keymap[e]
	if key in keyev:
		return keyev[key]
	if key in moev:
		mouse = bge.logic.mouse
		if key == bge.events.MOUSEX:
			return (mouse.position[0] - 0.5) * 2
		elif key == bge.events.MOUSEY:
			return (mouse.position[1] - 0.5) * 2
		else:
			return moev[key]
		
def cek(keymap, e):
	keyev = keyboard.events
	moev = mouse.events
	print("the key is {0} neh".format(str(keymap[e])))
	#print(keyev)
	if keymap[e] in keyev:
		return keyev[keymap[e]]
	if keymap[e] in moev:
		return moev[keymap[e]]

class KX_ControlPoints(bge.types.KX_GameObject):
	defBy = 0
	type = "captureable"
	timeToLoseControl = 180#dipakai saat pemain menghilangkan control dari team lain
	timeToGainControl = 180#dipakai saat pemain meng gain control terhadap cp tersebut
	balance = 0
	def __init__(self, old_owner):
		self.defBy = self['defBy']
		
	
	#karena ini game mo beking ta optimize di low speck pc maka qt nda mo pake tuh run() dulu
	#jadi nda mo pake tuh auto regain control lagi sehingga dp regain controlnya manual
	def playerInsideCap(self, anyone):
		#nanti dulu qt taruh tare dp script, mo utamakan ka bot dulu
		pass

def resetAntrian(withUserToo = True):
	if withUserToo == False:
		for t in var.spawnLocByTeam:
			for sp in t:
				if var.PCO in sp.antrian:
					sp.antrian = []
					sp.antrian.append(var.PCO)
				else:
					sp.antrian = []

class KX_SpawnPoint(bge.types.KX_GameObject):
	antrian = []
	inUse = False
	team = 1
	def __init__(self, old_owner):
		self.antrian = []
		self.inUse = False
		self.team = 1
		self["daftar antri"] = str(self.antrian)
		self.addDebugProperty("daftar antri")
		if 'tim' in self:
			self.team = self['tim']
			
	def onPlayerLeavingSpawnRadius(self):
		#script pake bersama2 deng sensor near
		pass
	def onUpdateAntrian(self):
		pass
	
	def updateAntrian(self, player):
		if player not in self.antrian:
			self.antrian.append(player)
			self["daftar antri"] = str(self.antrian)
			self.onUpdateAntrian()
			
	def delAntrian(self, player):
		if player in self.antrian:
			del self.antrian[self.antrian.index(player)]
			self["daftar antri"] = str(self.antrian)
			
	def resetAntrian(self, withUserToo = True):
		if withUserToo == False:
			if var.PCO in self.antrian:
				self.antrian = []
				self.antrian.append(var.PCO)
				self.inUse = True
			else:
				self.antrian = []
				self.inUse = False
		else:
			self.antrian = []
		self["daftar antri"] = str(self.antrian)
		
			
	def setInUse(self):
		self.inUse = True
	def setNotUse(self):
		self.inUse = False
		self.onPlayerLeavingSpawnRadius()
		
def rotateL(obj):
	if 'rot_speed' in obj:
		obj.applyRotation([obj['rot_speed'], 0, 0], True)
	else:
		obj.applyRotation([0.2, 0, 0], True)
def rotateR(obj):
	if 'rot_speed' in obj:
		obj.applyRotation([-obj['rot_speed'], 0, 0], True)
	else:
		obj.applyRotation([-0.2, 0, 0], True)
		
class mouseLook(bge.types.KX_GameObject):
	def __init__(self, old_owner):
		self.enableAxisX = True
		self.enableAxisY = True
		self.isEnable = True
		self.lastPos = [bge.logic.mouse.position[0], bge.logic.mouse.position[1]]
		#self.lastPos = [0,0]
		self.tiksBeforeReset = 3
		self.tiksForReset = 0
		self.rotX = 0.0
		self.rotZ = 0.0
		#self.sensitivity = 0.2
		self.maxRotX = 90
		if 'maxRotX' in self:
			self.maxRotX = self['maxRotX']
		self.minRotX = -90
		if 'minRotX' in self:
			self.minRotX = self['minRotX']
		self.maxRotZ = 180
		if 'maxRotZ' in self:
			self.maxRotZ = self['maxRotZ']
		self.minRotZ = -180
		if 'minRotZ' in self:
			self.minRotZ = self['minRotZ']
		self.resetX = False
		self.resetY = False
		if 'resetX' in self:
			self.resetX = self['resetX']
		if 'resetY' in self:
			self.resetY = self['resetY']
			
		#testSowMouse
		#bge.logic.mouse.visible = True
			
	def run(self):
		mo = bge.logic.mouse
		mousePos = [mo.position[0], mo.position[1]]
		#this should be linked to global settings
		sensitivity = var.soldierLookSensitivity
		'''
		jx = mousePos[0] - self.lastPos[0]
		jy = mousePos[1] - self.lastPos[1]
		jarak = (jx, jy)
		'''
		assign = (mo.position[0], mo.position[1])
		jarak = (mousePos[0] - self.lastPos[0], mousePos[1] - self.lastPos[1])
		if self.isEnable == True:
			if mousePos[0] + jarak[0] > 0.95:
				assign = (0.06, mousePos[1])
			if mousePos[0] + jarak[0] < 0.05:
				assign = (0.94, mousePos[1])
				
			mo.position = assign
			
			mPos = Vector(mousePos) - Vector((0.5, 0.5))
		
			#print([jarak, mPos])
			if self.enableAxisY == True:
				self.applyRotation([0.0, 0.0, -mPos[0]*sensitivity], False)
			if self.enableAxisX == True:
				if self.rotX + degrees(mPos[1]*sensitivity) > self.minRotX and self.rotX + degrees(mPos[1]*sensitivity) < self.maxRotX:
					self.applyRotation([-mPos[1]*sensitivity, 0.0, 0.0], True)
					#print("a --> " + str(self.rotX + degrees(mPos[1]*sensitivity)))
					self.rotX += degrees(mPos[1]*sensitivity)
					#print("b --> " + str(self.rotX))
			
			self.lastPos = [mo.position[0], mo.position[1]]
			bge.render.setMousePosition(int(bge.render.getWindowWidth() / 2), int(bge.render.getWindowHeight() / 2))
		
		#rencananya mo beking rupa tu gun rot deng turret rot pe script noh
		
#script get_dimesion credits from https://blenderartists.org/forum/showthread.php?338711-How-to-get-an-Object-s-dimensions-in-the-BGE
def get_dimensions(obj):
    mesh = obj.meshes[0]
    collection = [[], [], []]
    for mat_index in range(mesh.numMaterials):
        for vert_index in range(mesh.getVertexArrayLength(mat_index)):
            vert_XYZ = mesh.getVertex(mat_index, vert_index).XYZ
            [collection[i].append(vert_XYZ[i]) for i in range(3)]
    return Vector([abs(max(axis)) + abs(min(axis)) for axis in collection])
	
def setUpVehicle(cont):
	own = cont.owner
	newVehicle = KX_VehicleObject(own)
	kamus = var.globalDict
	newVehicle.setCont(cont)
	newVehicle['vehicle'] = True
	setWeapons(newVehicle)
	return newVehicle
	'''
	for i in cont.actuators:
		#if i.name != "bot state":
		#	cont.activate(i)
		cont.activate(i)
	'''
		
def setPlayerVehicle(own):
	cont = own.controllers['Python']
	if 'type' in own:
		if own['type'] == 'airplane':
			#newVehicle = KX_AirPlaneObject(own)
			newVehicle = KX_VehicleObject(own)
	else:
		newVehicle = KX_VehicleObject(own)
	kamus = var.globalDict
	#newVehicle.setCont(cont)
	newVehicle['vehicle'] = True
	setWeapons(newVehicle)
	'''
	for i in cont.actuators:
		#if i.name != "bot state":
		#	cont.activate(i)
		cont.activate(i)
	'''
	return newVehicle
	
def jetControl(self):
	if "initializeMouseControl" not in self:
		self['initializeMouseControl'] = True
		
		'''
		if 'maxRotX' not in self:
			self['maxRotX'] = radians(40)
		if 'maxRotY' not in self:
			self['maxRotY'] = radians(40)
		if 'maxRotZ' not in self:
			self['maxRotZ'] = radians(15)
		'''
		
		self.lastPos = [bge.logic.mouse.position[0], bge.logic.mouse.position[1]]
		
	else:
		mo = bge.logic.mouse
		mousePos = [mo.position[0], mo.position[1]]
		assign = (mo.position[0], mo.position[1])
		jarak = (mousePos[0] - self.lastPos[0], mousePos[1] - self.lastPos[1])
		if self.enableMouseControl == True:
			if mousePos[0] + jarak[0] > 0.95:
				assign = (0.06, mousePos[1])
			if mousePos[0] + jarak[0] < 0.05:
				assign = (0.94, mousePos[1])
				
			mo.position = assign
			
			#importing modul yg diperlukan untuk kontrol
			keyev = keyboard.events
			moev = mouse.events
			
			#control sectiom
			turnL = event(self.keymap, keyev, moev, 'turnL')
			turnR = event(self.keymap, keyev, moev, 'turnR')
			rollRight = event(self.keymap, keyev, moev, 'rollRight')
			rollLeft = event(self.keymap, keyev, moev, 'rollLeft')
			pitchUp = event(self.keymap, keyev, moev, 'pitchUp')
			pitchDown = event(self.keymap, keyev, moev, 'pitchDown')
			
			rx = 0.0
			ry = 0.0
			rz = 0.0
			
			(rvx, rvy, rvz) = self.getAngularVelocity(True)
			
			if turnL:
				if type(turnL) == int:
					rz = 1 * var.airPlaneMouseSensitivity
				else:
					rz = turnL * var.airPlaneMouseSensitivity
			if turnR:
				if type(turnR) == int:
					rz = -1 * var.airPlaneMouseSensitivity
				else:
					rz = turnR * var.airPlaneMouseSensitivity
			if rollRight:
				if type(rollRight) == int:
					ry =  -1 * var.airPlaneMouseSensitivity
				else:
					ry = rollRight * var.airPlaneMouseSensitivity
			if rollLeft:
				if type(rollLeft) == int:
					ry = 1 * var.airPlaneMouseSensitivity
				else:
					ry = rollLeft * var.airPlaneMouseSensitivity
			#if pitchUp or pitchDown:
			if pitchUp:
				if type(pitchUp) == int:
					rx = 1 * var.airPlaneMouseSensitivity
				else:
					rx = -pitchUp * var.airPlaneMouseSensitivity
			if pitchDown:
				if type(pitchDown) == int:
					rx = -1 * var.airPlaneMouseSensitivity
				else:
					rx = -pitchDown * var.airPlaneMouseSensitivity
			
			rvx += rx * self.localLinearVelocity.y / self.speedToPitch
			rvy += ry * self.localLinearVelocity.y / self.speedToRoll
			rvz += rz * self.localLinearVelocity.y / self.speedToYaw
			
			#print([rx,rx,rz])
			if rvz > self.maxRotZ:
				rvz = self.maxRotZ
			if rvz < -self.maxRotZ:
				rvz = -self.maxRotZ
			if rvy < -self.maxRotY:
				rvy = -self.maxRotY
			if rvy > self.maxRotY:
				rvy = self.maxRotY
			if rvx < -self.maxRotX:
				rvx = -self.maxRotX
			if rvx > self.maxRotX:
				rvx = self.maxRotX
					
			#print([rx, self['maxRotX']])
			
			#mPos = Vector(mousePos) - Vector((0.5, 0.5))
			
			#self.applyRotation([rx, ry, rz], True)
			self.setAngularVelocity([rvx, rvy, rvz], True)
			
			if var.ngecek == True:
				self['putaran'] = str([rvx, rvy, rvz])
				self.addDebugProperty("putaran")
			
			self.lastPos = [mo.position[0], mo.position[1]]
			bge.render.setMousePosition(int(bge.render.getWindowWidth() / 2), int(bge.render.getWindowHeight() / 2))
		
def getMaxSpeed(akselerasi, damping):
	maxTime = akselerasi / damping
	currentSpeed = 0.0
	for i in range(int(maxTime)):
		currentSpeed += akselerasi - i * damping
	return currentSpeed
	
def jetEngine(self):
	maju = 0.0
	force = 0.0
	gravity = -var.mapKonfigurasi['gravity']
	#gravity = 9.8
	#print('ok')
	faktorTanjakan = 1.0 - self.worldOrientation[2][1]
	vx = self.localLinearVelocity.x
	vy = self.localLinearVelocity.y
	#vy = self.forwardVelocity
	vz = self.localLinearVelocity.z
	'''
	newton_local_x = 0.45 * 0.025 * self.plane_size_x * (vx)**2
	newton_local_y = 0.45 * 0.025 * self.plane_size_y * (vy)**2
	newton_local_z = 0.45 * 0.025 * self.plane_size_z * (vz)**2
	
	diakselerasi_local_x = newton_local_x / self.mass / bge.logic.getLogicTicRate()
	diakselerasi_local_y = newton_local_y / self.mass / bge.logic.getLogicTicRate()
	diakselerasi_local_z = newton_local_z / self.mass / bge.logic.getLogicTicRate()
	'''
	
	#damping = 0.3
	#damping = self.linearDamping
	
	#self.forwardVelocity = diakselerasi_local_y
	gravityFactor = self.worldOrientation[2][1] * gravity * (1.0 - self.worldLinearVelocity.z / self.maxSpeed)
	currentAngularVelocity = self.getAngularVelocity(True)
	sx = sin(currentAngularVelocity[0] / bge.logic.getLogicTicRate())
	
	pitchFactor = 1.0
	'''
	if self.forwardVelocity > self.speedToPitch:
		if sx < 0:
			pitchFactor = sx + 1.0
		else:
			pitchFactor = 1.0 - sx
	'''
	if sx < 0:
		pitchFactor = sx + 1.0
	else:
		pitchFactor = 1.0 - sx
	#print([pitchFactor, sx, currentAngularVelocity[0], sx > 1, sx < -1])
	#print([pitchFactor, sx, currentAngularVelocity[0], self.forwardVelocity])
	#print(pitchFactor)
	#pitchFactor = 1.0 - sin((currentAngularVelocity[0] - self.lastAngularVelocity[0]) / bge.logic.getLogicTicRate())
	rollFactor = sin(currentAngularVelocity[1] - self.lastAngularVelocity[1])
	yawFactor = 1.0 - sin(currentAngularVelocity[2] - self.lastAngularVelocity[2])
	'''
	if pitchFactor < 0:
		pitchFactor *= -1
	if rollFactor < 0:
		rollFactor *= -1
	if yawFactor < 0:
		yawFactor *= -1
	'''
	self.forwardVelocity -= gravityFactor / bge.logic.getLogicTicRate()
	#self.forwardVelocity *= pitchFactor * rollFactor * yawFactor
	self.forwardVelocity *= pitchFactor
	if self.maju == 2:
		#self.forwardVelocity += (self.akselerasi - (gravity * self.worldOrientation[2][1]))
		#print([self.forwardVelocity, diakselerasi_local_y])
		#maju = self.forwardSpeed
		#force = self.forwardForce
		v = self.akselerasi * (1.0 - vy / self.maxSpeed)
		self["acc"] = str(v)
		#print(v)
		self.forwardVelocity += v / bge.logic.getLogicTicRate()
	else:
		#karena udarah itu tidak bergerak jadi velocity udarah ialah 0 maka tak perlu dikalikan lagi karna bisa memberi pengaru 0 pada momentumnya
		momentumUdara = var.mapKonfigurasi['masaUdara'] * self.plane_size_y
		momentumVehicle = self.forwardVelocity * self.mass
		if self.mundur:
			if self.forwardVelocity < 0.0:
				self.forwardVelocity -= 0.05
			else:
				self.forwardVelocity = (momentumVehicle - momentumUdara * 4)  / self.mass
		else:
			if self.forwardVelocity > 0.0:
				self.forwardVelocity = (momentumVehicle - momentumUdara)  / self.mass
				if self.forwardVelocity < 0.0:
					self.forwardVelocity = 0.0
			elif self.forwardVelocity < 0.0:
				self.forwardVelocity = -(-momentumVehicle - momentumUdara)  / self.mass
				if self.forwardVelocity > 0.0:
					self.forwardVelocity = 0.0
			'''
			elif self.forwardVelocity > 0.0:
				self.forwardVelocity -= 0.1
			'''
			#script diakselerasi taruh disini
	'''
	prototype rumus damping
	
	damping = 1 / (1 - persentase_damping_in_decimal)
	
	ket:
	- persentase_damping_in_decimal ialah 0.0 sampai 1.0
	
	cara I:
		v = ms / (damping*damping**(detik-1))
		contoh
		32 = 64 / (2*2**(1-1))
		16 = 64 / (2*2**(2-1))
		dan seterusnya
	
	maka simplenya ialah
	cara II:
		v = v / damping akan memiliki nilah
		32 = 64 / 2
		16 = 32 / 2
		
	dengan prinsip tersebut maka:
		ketika tombol maju diketik:
			detik berjalan
		else:
			detik = 0
			initial velocity berkurang secara bertahap karena tak ada percepatan dan pertahanan lagi
	'''
	#self.applyMovement([0.0, maju, 0.0], True)
	#self.localLinearVelocity.y += maju
	self.localLinearVelocity.y = self.forwardVelocity
	#self.setLinearVelocity([diakselerasi_local_x, self.forwardVelocity, diakselerasi_local_z], True)
	#self.applyForce([0.0, force, 0.0], True)
	
	g = gravity * self.mass
	
	'''
	air resistance = (density, drag, and area)/2 * currentSpeed
	air resistance = kg*m/s pangkat2
	atau
	air resistance = F = nilai N (newton)
	'''
	
	vwx = self.worldLinearVelocity.x
	vwy = self.worldLinearVelocity.y
	
	vvw = hypot(vwx, vwy)#vertical world velocity
	
	if vvw < 0.0:
		vvw *= -1
	
	#speedToLift is velocity m/s that plane needed to lift
	if vy <= self.speedToLift:
		self.liftForce = vvw / self.speedToLift * g * faktorTanjakan
		#self.liftForce = vvw / self.speedToLift * g
	else:
		self.liftForce = g * faktorTanjakan
		#self.liftForce = g
		#self.liftForce = vvw / self.speedToLift * g * faktorTanjakan
		
	#print([vvw, self.liftForce, g, vy])
	self.applyForce([0.0, 0.0, self.liftForce])
	
	#get last measurement
	self.lastFaktorTanjakan = faktorTanjakan
	self.lastAngularVelocity = self.getAngularVelocity(True)
	
	# ------------- Debugging Section ------------- #
	if var.ngecek == True:
		self['vel'] = str(vy)
		self.addDebugProperty('vel')
		kpj = int(vy * 3.6)
		self['km/h'] = str(kpj)
		self.addDebugProperty('km/h')
		self.addDebugProperty('acc')
		self['maxSpeed m/s'] = int(self.maxSpeed)
		self['maxSpeed km/s'] = int(self.maxSpeed * 3.6)
		self.addDebugProperty('maxSpeed m/s')
		self.addDebugProperty('maxSpeed km/s')
	# --------------------------------------------- #

class KX_VehicleObject(bge.types.KX_GameObject):
	useBy = None
	lastHitBy = None
	lastHitWith = None#dipisah supaya kalo misalnya player sdh mengganti kendaraan data kill kan dimasuk mengenai kendaraan yg sebelumnya yg melakukan kill tersebut
	initialHitPoints = 1000.0
	hitPoints = initialHitPoints
	def __init__(self, old_owner):
		self.delayForUse = 30
		if 'delayForUse' in self:
			self.delayForUse = self['delayForUse']
		if 'hitPoints' in self:
			self.initialHitPoints = self['hitPoints']
			self.hitPoints = self['hitPoints']
		self.delayForBailOut = 30
		if 'delayForBailOut' in self:
			self.delayForBailOut = self['delayForBailOut']
		self.playerSeatPos = self#warning this can cause some error
		self.playerExitPos = None
		#perencanaan untuk exit pos nantinya
		"""
		Akan ada beberapa exit pos in case kalo salah satu exit pos da ta halang deng objek laeng
		Sebelum player bisa exit, di perlukan sensor untuk mendeteksi jika ada objek laeng yg menghalangi dp posisi exit
		Untuk bisa mendeteksi maka pada exit pos akan di spawn objek khusu untuk mendeteksi (sebuah sensor physic) objek laeng dan me-remove-nya setelah ia melakukan pekerjaannya
		dengan hal tersebut maka diperlukan rentan 1 logic step untuk mengeceknya dan 1 logic step untuk me-remove-nya kemudian menaruh datanya ke dalam array available exit pos
		kemudian mengecek jika ada tempat yg frei untuk player bisa exit
		if ada maka:
			player exit di frei
		else:
			player tak bisa exit lagi
		"""
		self[var.penandaPlayer] = True#agar sebentar beberapa sensor bisa mendeteksi objek dari ini
		self.tiks = 0
		self.team = 1
		self.target = None
		self.currentWeapon = None
		self.primaryWeapon = None
		self.weapons = []
		self.guiIndex = None
		if 'guiIndex' in self:
			self.guiIndex = self['guiIndex']
		self.tipe = "mobil"
		if 'type' in self:
			self.tipe = self['type']
		self.wIndex = 0
		self.owner = None
		self.dummyDict = {}
		self.keymap = var.globalDict['control']['control_kendaraan_umum']
		if 'keymap' in self:
			#self.keymap = self['keymap']
			self.keymap = var.globalDict['control'][self['keymap']]
			
		#print("keymap of this vehicle {0} is {1}".format(self.name, str(self.keymap)))
		
		self.GUIID = 'default'
		if 'GUIID' in self:
			self.GUIID = self['GUIID']
			
		# --------------- Camera Set ---------------
		#rencana untuk camera dibagi menjadi 2 yaitu Third Person dengan menggunakan camPoros atau hanya First Person tanpa menggunakan camPoros
		self.camPos = None
		self.camPoros = None
		# ------------------------------------------
		
		#a player that drive this vehicle
		self.driveBy = None
		
		self.gearRight = []
		self.gearLeft = []
		
		self.track_right = None
		self.track_left = None
		
		# ------------ Jet Section ------------ #
		self.jet_engines = []
		self.jet_engine_is_exist = False
		self.enableMouseControl = False
		if self.tipe == "airplane":
			self.enableMouseControl = True
		self.dimensi = get_dimensions(self)
		self.plane_size_x = hypot(self.dimensi[1], self.dimensi[2])
		self.plane_size_y = hypot(self.dimensi[0], self.dimensi[2])
		self.plane_size_z = hypot(self.dimensi[0], self.dimensi[1])
		#total_rotation gonna use in counting rotation speed as factor untuk mengurangi kecepatan pada axisnya
		self.total_rotation_x = 0.0
		self.total_rotation_y = 0.0
		self.total_rotation_z = 0.0
		self.forwardVelocity = 0.0
		self.lastFaktorTanjakan = 1.0 - self.worldOrientation[2][1]
		self.lastAngularVelocity = self.getAngularVelocity(True)
		self.akselerasi = 9.8
		if 'akselerasi' in self:
			self.akselerasi = self['akselerasi']
		self.liftForce = 0.0
		self.speedToLift = 350
		if 'speedToLift' in self:
			self.speedToLift = self['speedToLift']
		self.forwardForce = 1.0
		if 'forwardForce' in self:
			self.forwardForce = self['forwardForce']
		self.damping = 0.04
		if "damping" in self:
			self.damping = self['damping']
		self.maxSpeed = getMaxSpeed(self.akselerasi, self.damping)
		
		self.speedToPitch = 350 / 3.6#350km/s diubah ke meter/detik
		self.speedToRoll = 350 / 3.6
		self.speedToYaw = 350 / 3.6
		
		if 'speedToPitch' in self:
			self.speedToPitch = self['speedToPitch'] / 3.6
		if 'speedToRoll' in self:
			self.speedToRoll = self['speedToRoll'] / 3.6
		if 'speedToYaw' in self:
			self.speedToYaw = self['speedToYaw'] / 3.6
		self.maxRotX = radians(40)
		self.maxRotY = radians(40)
		self.maxRotZ = radians(15)
		if 'maxRotX' in self:
			self.maxRotX = radians(self['maxRotX'])
		if 'maxRotY' in self:
			self.maxRotY = radians(self['maxRotY'])
		if 'maxRotZ' in self:
			self.maxRotZ = radians(self['maxRotZ'])
		# ------------ For jet AI -------------
		tikRate = bge.logic.getLogicTicRate()
		self.botMaxRotX = self.maxRotX / tikRate
		self.botMaxRotY = self.maxRotY / tikRate
		self.botMaxRotZ = self.maxRotZ / tikRate
		self.botTimeToFlight = 20*tikRate
		if 'botTimeToFlight' in self:
			self.botTimeToFlight = self['botTimeToFlight'] * bge.logic.getLogicTicRate()
		# ------------------------------------- #
		
		self.changeWeapon1 = 0
		self.changeWeapon2 = 0
		self.tembak = 0
		self.tembak2 = 0
		self.zoomIn = 0
		self.zoomOut = 0
		self.changetarget = 0

		self.maju = nope
		self.mundur = nope
		self.turnL = nope
		self.turnR = nope
		
		self.keluar = nope
		
		#self.forwardSpeed = 0.2
		self.forwardSpeed = 5.2
		if 'forwardSpeed' in self:
			#self.forwardSpeed = self['forwardSpeed'] / bge.logic.getLogicTicRate()
			self.forwardSpeed = self['forwardSpeed']
		self.backwardSpeed = 0.05
		if 'backwardSpeed' in self:
			self.backwardSpeed = self['backwardSpeed']
		self.turnSpeed = 0.7
		if 'turnSpeed' in self:
			self.turnSpeed = self['turnSpeed']
			
		
		#self.scene = bge.logic.getCurrentScene()
		self.interceptPoint = None
		if interceptPoint not in self.childrenRecursive:
			self.interceptPoint = self.scene.addObject(interceptPoint, self)#perlu mo hapus kalo main objeknya udah mokat
			#self.interceptPoint.groupObject(self)
			#self.interceptPoint.setParent(self)
			
			
		''' ---------------------------- Checking up the other bundle ---------------------------- '''
		hitung = 0
		passed = 0
		for obj in self.childrenRecursive:
			hitung += 1
			try:
				print("{0} is ok".format(obj.name))
				if 'gear_right' in obj:
					self.gearRight.append(obj)
				if 'gear_left' in obj:
					self.gearLeft.append(obj)
				if 'track_right' in obj:
					self.track_right = obj
				if 'track_left' in obj:
					self.track_left = obj
				if 'setAsPrimaryCam' in obj:
					self.camPos = obj
				if 'setAsPlayerSeat' in obj:
					self.playerSeatPos = obj
				if 'playerExitPos' in obj:
					self.playerExitPos = obj
				if 'jet_engine' in obj:
					self.jet_engine_is_exist = True
					self.jet_engines.append(obj)
				#semua object yg di mutate harus kasih di akhir sectionnya untuk mencegah error
				if 'setAsCamPoros' in obj:
					self.camPoros = mouseLook(obj)
					
				#weaponSection
				if 'createPrimaryWeapon' in obj:
					self.primaryWeapon = weapons(obj, self)
			except SystemError:
				print("passing some object")
				passed += 1
				#print(obj)
		print("total object dalam vehicle {0} ialah {1} dan yg terlewati ialah {2}".format(self.name, str(hitung), str(passed)))
		''' --------------------------------------------------------------------------------------- '''
		
	def setCamPos(self):
		''' ------------------------------ Settingup Camera Position ------------------------------ '''
		if self.owner == var.PCO:
			if self.camPos != None:
				camPos = self.camPos
				try:
					if camPos != self.scene.active_camera:
						self.scene.active_camera = camPos
				except TypeError:
					print("error on gameobjects setCamPos function; you you're trying to add object that does not a cam object")
		else:
			print('self.name' + " camPos is None")
		''' --------------------------------------------------------------------------------------- '''
		
	def addLookAt(self):
		if var.lastAddedGameObjectId == id(self):
			print(' --------- Adding lookAt object --------- ')
			#self.scene.addObject('lookAt')
			print(' ---------------------------------------- ')
		else:
			print("objek {0} is not the lastAddedGameObject".format(self.name))
			print('referensi {0} missmatch {1}'.format(str(id(self)), str(var.lastAddedGameObjectId)))
			
	def setCont(self, cont):
		self.cont = cont
		#fungsi setCont mungkin akan dihapus di kemudian harinya
		
	def cek(self):
		print("test neh")
	
	def hit(self, hitpoints):
		self.hitPoints -= hitpoints
		if self.hitPoints < 0:
			print('destroying object because that object HP is below zero')
			self.destroy()
	def destroy(self):
		#algoritma lainnya sperti
		#play effect
		#play destroying sound
		#change camera
		if self == var.player:
			self.scene.active_camera = self.scene.cameras['inGameMainCam']
			var.player = None
		self.endObject()
		
	def setTarget(self, target, sens):
		self.target = target
		if hasattr(self.owner, "setTargetBySensing"):
			self.owner.setTargetBySensing(target, sens)
			#print(target)
		
	def runPlayer(self):
		try:
			keyev = keyboard.events
			moev = mouse.events
			'''
			if keyev[bge.events.FKEY] > 0:
				self.changeWeapon1 = cek(keymap, 'changeWeapon1')
				print(self.changeWeapon1)
			
			'''
			self.changeWeapon1 = event(self.keymap, keyev, moev, 'changeWeapon1')
			self.changeWeapon2 = event(self.keymap, keyev, moev, 'changeWeapon2')
			self.tembak = event(self.keymap, keyev, moev, 'tembak')
			self.tembak2 = event(self.keymap, keyev, moev, 'tembak2')
			#self.zoomIn = event(self.keymap, keyev, moev, 'zoomIn')
			#self.zoomOut = event(self.keymap, keyev, moev, 'zoomOut')
			self.changetarget = event(self.keymap, keyev, moev, 'changetarget')
			
			self.maju = event(self.keymap, keyev, moev, 'maju')
			self.mundur = event(self.keymap, keyev, moev, 'mundur')
			self.turnL = event(self.keymap, keyev, moev, 'turnL')
			self.turnR = event(self.keymap, keyev, moev, 'turnR')
			
			#self.keluar = event(self.keymap, keyev, moev, 'keluar')
			
		except:
			checker.getInfo(keyev)
			bge.logic.endGame()
			
		try:
			''' -------------------------------- Camera Section -------------------------------- '''
			if hasattr(self.camPoros, 'run') == True:
				self.camPoros.run()
			''' -------------------------------------------------------------------------------- '''
			
			''' -------------------------------- Weapon Section -------------------------------- '''
			wp = len(self.weapons)
			if wp > 0:
				if self.currentWeapon == None:
					self.currentWeapon = self.weapons[0]
					self.wIndex = 0
				else:
					if wp > 1:
						#print(self.changeWeapon1)
						if self.changeWeapon1 == jaktif:
							if self.wIndex < wp - 1:
								selanjutnya = self.wIndex+1
								self.currentWeapon = self.weapons[selanjutnya]
								#HUD.weapon_name.text = self.currentWeapon.name
								self.wIndex += 1
							else:
								self.currentWeapon = self.weapons[0]
								#HUD.weapon_name.text = self.currentWeapon.name
								self.wIndex = 0
							print('object {0} is changing weapon to {1}'.format(self.name, self.currentWeapon.name))
						if self.changeWeapon2 == jaktif:
							if self.wIndex > 0:
								selanjutnya = self.wIndex-1
								self.currentWeapon = self.weapons[selanjutnya]
								#HUD.weapon_name.text = self.currentWeapon.name
								self.wIndex = selanjutnya
							else:
								reset = wp - 1
								self.currentWeapon = self.weapons[reset]
								#HUD.weapon_name.text = self.currentWeapon.name
								self.wIndex = reset
							print('object {0} is changing weapon to {1}'.format(self.name, self.currentWeapon.name))
						
					
					if self.currentWeapon.lockedTo == None:
						lookAt = mainscript.lookAt
						if lookAt != None:
							self.interceptPoint.position = lookAt
						else:
							self.interceptPoint.position = self.scene.objects['lookAtDummy'].position
					#if self.tembak == aktif:
					#	self.currentWeapon.fire()
					self.currentWeapon.checkFire(self.tembak2)
					self.primaryWeapon.checkFire(self.tembak)
					if self.tipe != "airplane":
						self.currentWeapon.run(self.interceptPoint, self.owner)
			''' -------------------------------------------------------------------------------- '''
			
			''' ------------------------------- Movement Section ------------------------------- '''
			if self.tipe == 'ground_tank':
				if type(self.track_left) == bge.types.KX_GameObject and type(self.track_right) == bge.types.KX_GameObject:
					maju = 0.0
					if self.maju == 2:
						for i in self.gearLeft:
							#rotateL(i)
							rotateR(i)
						for i in self.gearRight:
							rotateR(i)
						maju = self.forwardSpeed
					if self.mundur == 2:
						for i in self.gearLeft:
							#rotateL(i)
							rotateL(i)
						for i in self.gearRight:
							rotateL(i)
						maju = -self.backwardSpeed
					self.applyMovement([0, maju, 0], True)
					belok = 0.0
					if self.turnL == 2:
						belok = self.turnSpeed
					if self.turnR == 2:
						belok = -self.turnSpeed
					self.applyRotation([0,0,belok], True)
				if self.jet_engine_is_exist == True:
					jetEngine(self)
			elif self.tipe == 'airplane':
				if self.jet_engine_is_exist == True:
					jetEngine(self)
					jetControl(self)
			else:
				if self.jet_engine_is_exist == True:
					jetEngine(self)
			''' -------------------------------------------------------------------------------- '''
			
			''' ------------------------------- Exiting Section -------------------------------- '''
			'''
			if self.keluar == jaktif and self.tiks > self.delayForBailOut:
				var.player = self.driveBy
				self.driveBy.camPosHere()
				eul = self.playerExitPos.worldOrientation.to_euler()
				eul = Euler((0.0, 0.0, eul.z), 'XYZ')
				self.driveBy.worldOrientation = eul.to_matrix()
				self.driveBy.removeParent()
				self.driveBy.disableRigidBody()
				self.driveBy.position = self.playerExitPos.position
				z = eul.z
				self.driveBy = None
				self.useBy = None
				#nanti kalo somo pake penumpang kong tu penumpang mo pindah tampa nanti pake switch rupa temp = self.driveBy self.driveBy = self.penumpang1 lalu self.penumpang1 = temp. Yah rupa itulah
			'''
			''' -------------------------------------------------------------------------------- '''
			
			#tikking section
			self.tiks += 1
		except:
			checker.getInfo()
			bge.logic.endGame()
		
	def runJetEngine(self):
		jetEngine(self)
	def runBot(self):
		pass
		
class KX_AirPlaneObject(KX_VehicleObject):
	def __init__(self, old_owner):
		pass
class KX_TankObject(KX_VehicleObject):
	def __init__(self, old_owner):
		pass
	
	def runPlayer(self):
		try:
			keyev = keyboard.events
			moev = mouse.events
			
			self.maju = event(self.keymap, keyev, moev, 'maju')
			self.mundur = event(self.keymap, keyev, moev, 'mundur')
			self.turnL = event(self.keymap, keyev, moev, 'turnL')
			self.turnR = event(self.keymap, keyev, moev, 'turnR')
			
			''' ------------------------------- Movement Section ------------------------------- '''
			if self.tipe == 'ground_tank':
				if type(self.track_left) == bge.types.KX_GameObject and type(self.track_right) == bge.types.KX_GameObject:
					maju = 0.0
					if self.maju == 2:
						for i in self.gearLeft:
							#rotateL(i)
							rotateR(i)
						for i in self.gearRight:
							rotateR(i)
						maju = self.forwardSpeed
					if self.mundur == 2:
						for i in self.gearLeft:
							#rotateL(i)
							rotateL(i)
						for i in self.gearRight:
							rotateL(i)
						maju = -self.backwardSpeed
					self.applyMovement([0, maju, 0], True)
					belok = 0.0
					if self.turnL == 2:
						belok = self.turnSpeed
					if self.turnR == 2:
						belok = -self.turnSpeed
					self.applyRotation([0,0,belok], True)
			''' -------------------------------------------------------------------------------- '''
		except:
			checker.getInfo()
			bge.logic.endGame()
	
class KX_SoldierObject(bge.types.KX_GameObject):
	def __init__(self, old_owner):
		self[var.penandaPlayer] = True#agar bisa dideteksi oleb spesifik sensor
		self.team = 1
		self.target = None
		self.lookIsEnable = True
		self.currentWeapon = 1
		self.arms = []
		for i in range(0, 10):
			self.arms.append(None)
		self.hadWeapon = False
		self.wIndex = 0
		self.guiIndex = None
		if 'guiIndex' in self:
			self.guiIndex = self['guiIndex']
		self.useBy = None
		self.dummyDict = {}
		self.keymap = var.globalDict['control']['control_player']
		self.raySensor = None
		#self.lookAtObject = None
		'''
		self.lookAtSensor = None
		if 'lookAt' in self.scene.objects:
			temp = self.scene.objects['lookAt']
			if 'mOver' in temp.sensors:
				if type(temp.sensors['mOver']) == bge.types.KX_RaySensor:
					self.lookAtSensor = temp.sensors['mOver']
					print("apllying lookAtSensors")
		'''
		
		self.changeWeapon1 = 0
		self.changeWeapon2 = 0
		self.tembak = 0
		self.tembak2 = 0
		self.zoomIn = 0
		self.zoomOut = 0
		self.changetarget = 0
		
		self.normalSpeed = 0.08
		self.sprintSpeed = 0.2
		if 'normalSpeed' in self:
			self.normalSpeed = self['normalSpeed']
		if 'sprintSpeed' in self:
			self.sprintSpeed = self['sprintSpeed']
		self.jumpVelocity = 0.7
		if 'jumpVelocity' in self:
			self.jumpVelocity = self['jumpVelocity']
			
		self.GUIID = 'default'
		if 'GUIID' in self:
			self.GUIID = self['GUIID']
			
		self.bundleX = None
		self.camParent = None
		for i in self.childrenRecursive:
			if 'cam_parent_here' in i:
				self.camParent = i
			if "mouseX here" in i:
				self.bundleX = mouseLook(i)
				print("binding mouseLook script to object {0} is success".format(self.bundleX.name))
				#self.bundleX = i
				self.bundleX.enableAxisY = False
				
		if type(self.bundleX) == bge.types.KX_GameObject or type(self.bundleX) == mouseLook:
			self.camPosHere()
			
		self.enableMouseControl()
		
	def camPosHere(self):
		camera = self.scene.active_camera.parent
		camPos = self.camParent
		#print(" ------------- Setting up player campos --------------- ")
		#print(self.scene)
		#print(self.scene.active_camera)
		#print(camera)
		#print(" ------------------------------------------------------ ")
		
		#print(" ------------------------ AAAAAAAAAAAAAAAAAAAA {0} --------------------------- ".format(str(porosKamera)))
		
		if var.scene['camPosIsOn'] != self:
			var.scene['camPosIsOn'] = self
			if camera.parent != None:
				camera.removeParent()
			camera.position = camPos.position
			camera.worldOrientation = camPos.worldOrientation
			camera.setParent(camPos)
			self.enableMouseControl()
			#camPos['terParent'] = True
	
	def enableMouseControl(self):
		self.lookIsEnable = True
		if type(self.bundleX) == bge.types.KX_GameObject or type(self.bundleX) == mouseLook:
			self.bundleX.isEnable = True
		
	def disableMouseControl(self):
		self.lookIsEnable = False
		if type(self.bundleX) == bge.types.KX_GameObject or type(self.bundleX) == mouseLook:
			self.bundleX.isEnable = False
				
	def rotZ(self):
		mo = bge.logic.mouse
		rm = mo.position[0] - 0.5
		if self.lookIsEnable == True:
			self.applyRotation([0.0, 0.0, -rm*var.soldierLookSensitivity], False)
		
	def runPlayer(self):
		try:
			inVehicle = False#qt baru inga kote karna qt malas mo unindent samua maka qt cuma pake logic if tare :3
			if inVehicle == False:
				if type(self.bundleX) == mouseLook:
					self.bundleX.run()
				self.rotZ()
				keyev = keyboard.events
				moev = mouse.events
				'''
				if keyev[bge.events.FKEY] > 0:
					self.changeWeapon1 = cek(keymap, 'changeWeapon1')
					print(self.changeWeapon1)
				
				'''
				self.changeWeapon1 = event(self.keymap, keyev, moev, 'changeWeapon1')
				self.changeWeapon2 = event(self.keymap, keyev, moev, 'changeWeapon2')
				self.tembak = event(self.keymap, keyev, moev, 'tembak')
				self.quickZoom = event(self.keymap, keyev, moev, 'quickZoom')
				#self.tembak2 = event(self.keymap, keyev, moev, 'tembak2')
				self.use = event(self.keymap, keyev, moev, 'use')
				self.zoomIn = event(self.keymap, keyev, moev, 'zoomIn')
				self.zoomOut = event(self.keymap, keyev, moev, 'zoomOut')
				
				self.maju = event(self.keymap, keyev, moev, 'maju')
				self.mundur = event(self.keymap, keyev, moev, 'mundur')
				self.kiri = event(self.keymap, keyev, moev, 'kiri')
				self.kanan = event(self.keymap, keyev, moev, 'kanan')
				
				self.sprint = event(self.keymap, keyev, moev, 'sprint')
				self.lompat = event(self.keymap, keyev, moev, 'lompat')
				
				maju = 0.0
				samping = 0.0
				if self.maju == aktif:
					if self.sprint == aktif:
						maju = self.sprintSpeed
					else:
						maju = self.normalSpeed
				if self.mundur == aktif and self.maju == nope:
					maju = -self.normalSpeed
					
				if self.sprint == nope:
					if self.kiri == aktif and self.kanan == nope:
						samping = -self.normalSpeed
					if self.kiri == nope and self.kanan == aktif:
						samping = self.normalSpeed
				else:
					if self.kiri == aktif and self.kanan == nope:
						samping = -self.sprintSpeed
					if self.kiri == nope and self.kanan == aktif:
						samping = self.sprintSpeed
						
				self.applyMovement([samping, maju, 0.0], True)
				#self.applyMovement([0, 0.01, 0])
				#self.position.y += 0.01
				#print([self.maju, maju, self.position])
				
				if self.lompat == jaktif:
					#print("player melompat")
					#print("status variable ray sensor ialah : " + str(self.raySensor))
					if self.raySensor != None:
						#print("sensor raynya ialah " + str(self.raySensor.positive))
						if self.raySensor.positive == 1:
							#self.applyForce([0.0, 0.0, self.jumpVelocity], True)
							self.localLinearVelocity.z = self.jumpVelocity
					
				if var.scene['playerLookAtObject'] != None:
					lookAtObject = var.scene['playerLookAtObject']
					if lookAtObject in self.scene.objects and var.scene['playerLookAtRange'] != None:
						#HUD.willUseStatusText = lookAtObject.name
						if var.scene['playerLookAtRange'] <= var.globalDict['rangeOfUse']:
							if 'thisIsWeapon' in lookAtObject:
								senjata = lookAtObject
								#print("printing the text over the HUD")
								if 'itemIndex' in senjata:
									if self.arms[senjata['itemIndex']] == None:
										HUD.willUseStatusText = "take_item " + senjata.name
										if self.use == lepas and self.bundleX != None:
											self.arms[senjata['itemIndex']] = senjata
											senjata.setParent(self.bundleX, False, True)
											if self.hadWeapon == False:
												self.currentWeapon = senjata['itemIndex']
												senjata.setOnUse(self.bundleX)
												self.hadWeapon = True
											else:
												if var.alwaysUseNewlyTakenItem == True:
													self.arms[self.currentWeapon].setAsBackUp()
													self.currentWeapon = senjata['itemIndex']
													senjata.setOnUse(self.bundleX)
												else:
													if self.currentWeapon == senjata['itemIndex']:
														senjata.setOnUse(self.bundleX)
													else:
														senjata.setAsBackUp()
									else:
										if self.arms[senjata['itemIndex']].name == senjata.name:
											if senjata.mag > 0:
												HUD.willUseStatusText = "add_ammo"
												if self.use == lepas and self.bundleX != None:
													size = self.arms[senjata['itemIndex']].magSize - 1
													magLeft = self.arms[senjata['itemIndex']].mag
													ygDiPerlukan = size - magLeft
													if self.arms[senjata['itemIndex']].reloadStatus == "abis":
														self.arms[senjata['itemIndex']].reloadStatus = "standBy"
													if ygDiPerlukan <= senjata.mag:
														sisa = senjata.mag - ygDiPerlukan
														ygDiambil = ygDiPerlukan
														senjata.mag = sisa
														self.arms[senjata['itemIndex']].mag += ygDiambil
													else:
														if ygDiPerlukan > 0:
															sisa = 0
															ygDiambil = senjata.mag
															senjata.mag = sisa
															self.arms[senjata['itemIndex']].mag += ygDiambil
														
										else:
											HUD.willUseStatusText = "replace_item " + self.arms[senjata['itemIndex']].name + " with " + senjata.name
											if self.use == lepas and self.bundleX != None:
												self.arms[senjata['itemIndex']].removeParent()
												#self.arms[senjata['itemIndex']].restoreDynamics()
												self.arms[senjata['itemIndex']].visible = True
												self.arms[senjata['itemIndex']] = senjata
												senjata.worldOrientation = self.bundleX.worldOrientation
												senjata.setParent(self.bundleX, False, True)
												if var.alwaysUseNewlyTakenItem == True:
													self.arms[self.currentWeapon].setAsBackUp()
													self.currentWeapon = senjata['itemIndex']
													senjata.setOnUse(self.bundleX)
												else:
													if self.currentWeapon == senjata['itemIndex']:
														senjata.setOnUse(self.bundleX)
													else:
														senjata.setAsBackUp()
							if 'vehicle' in lookAtObject:
								HUD.willUseStatusText = "Get in vehicle"
								if self.use == jaktif:
									var.player = lookAtObject
									lookAtObject.driveBy = self
									lookAtObject.useBy = "player"
									lookAtObject.tiks = 0
									self.position = lookAtObject.playerSeatPos.position
									self.worldOrientation = lookAtObject.playerSeatPos.worldOrientation
									self.setParent(lookAtObject)
									HUD.willUseStatusText = ""
									self['enableMouse'] = False
									if self.bundleX != None:
										self.bundleX['enableMouse'] = False
						else:
							HUD.willUseStatusText = ""
					else:
						print("error some object is not in list")
						HUD.willUseStatusText = "error some object is not in list"
				else:
					#print("look at Object is None")
					pass
						
				if self.changeWeapon1 == jaktif:
					isNone = True
					notNoneCount = 0
					notNoneList = []
					pa = len(self.arms)
					for i in self.arms:
						if i != None:
							isNone = False
							notNoneCount += 1
							notNoneList.append(i)
					if isNone == False:
						if notNoneCount > 1:
							temp = self.currentWeapon
							#print(''' -------------------------------- ''')
							for i in range(pa):
								if temp < pa-1:
									temp += 1
								else:
									temp = 1
								#print(temp)
								if self.arms[temp] != None:
									break
							#print(''' -------------------------------- ''')
							self.arms[self.currentWeapon].setAsBackUp()
							self.arms[temp].setOnUse(self.bundleX)
							self.currentWeapon = temp
						#elif notNoneCount == 1:
						#	self.currentWeapon = notNoneList[0]['itemIndex']
					
					#print(''' -------------------------------- ''')
					#print([isNone, notNoneCount])
					#print(''' -------------------------------- ''')
				'''
				for i in self.arms:
					if i != None:
						i['itemIndex'] == self.currentWeapon:
							i.checkFire(self.tembak)
						else:
							i.checkFire(nope)
				'''
				if self.arms[self.currentWeapon] != None:
					self.arms[self.currentWeapon].checkFire(self.tembak)
				
		except:
			checker.getInfo()
			bge.logic.endGame()
		
	def runBot(self):
		try:
			inVehicle = False
			if inVehicle == False:
				#ai script put here
				pass
		except:
			checker.getInfo()
			bge.logic.endGame()
			
def createSoldierWeapon(cont):
	own = cont.owner
	newWeapon = KX_soldierWeapon(own)
	newWeapon.setController(cont)
	for i in cont.actuators:
		cont.activate(i)
			
class KX_soldierWeapon(bge.types.KX_GameObject):
	def __init__(this, old_owner):
		this.tipe = None
		this.useBy = None
		this.cont = None
		this.ZBundle = None
		this.XBundle = None
		this.barelZ = None
		this.pBarelZ_poros = None
		this.barelX = None
		this.weaponGUI = None
		if 'weaponGUI' in this:
			this.weaponGUI = this['weaponGUI']
		
		this.barels = []
		this.unShootBarels = []
		for child in this.childrenRecursive:
			if 'createBarel' in child:
				this.barels.append(child)
		if len(this.barels) == 0:
			this.barels.append(this)
		
		this.shootOneByOne = False
		this.lockedTo = None
		this.velocity = 20
		this.output = Vector([0.0, 1.0, 0.0])
		this.ammoSize = 30
		if 'ammoSize' in this:
			this.ammoSize = this['ammoSize']
		this.magSize = 7
		if 'magSize' in this:
			this.magSize = this['magSize']
		this.ammo = this.ammoSize
		this.mag = this.magSize
		this.interval = 0.1
		if 'interval' in this:
			this.interval = this['interval']
		this.reloadTime = 2.0
		if 'reloadTime' in this:
			this.reloadTime = this['reloadTime']
		this.reloadTimeLeft = this.reloadTime
		this.autoReload = True
		this.isReloading = False#rencana tuk dihapus
		this.reloadStatus = "awal"
		this.lastTimeOfFire = datetime.datetime.now()
		#this.readyToFire = False
		#this.readyToFire = True
		this.shell = 'generic shell'
		if 'type' in this:
			this.tipe = this['type']
		if this.tipe == "linear":
			this.shell = "linear_shell"
		if 'shell' in this:
			this.shell = this['shell']
		this.scale = "[1.0, 1.0, 1.0]"
		if 'scale' in this:
			this.scale = this['scale']
		this.timeToLive = 11
		if 'timeToLive' in this:
			this.timeToLive = this['timeToLive']
		this.infinityAmmo = False
		if "infinityAmmo" in this:
			this.infinityAmmo = this['infinityAmmo']
		this.infinityMag = False
		if 'infinityMag' in this:
			this.infinityMag = this['infinityMag']
		this.resetAsMain = False
		if 'resetAsMain' in this:
			this.resetAsMain = this['resetAsMain']
		this.hideWhenUnused = True
		if 'hideWhenUnused' in this:
			this.hideWhenUnused = this['hideWhenUnused']
		
		if 'velocity' in this:
			this.velocity = this['velocity']
		
		this.aimPoint = None
		
	def setController(this, cont):
		this.cont = cont
		
	'''
	def parentkan(this, obj):
		this.setParent(obj, False, True)
		if this.resetAsMain == True:
			if 'pos' in this:
				exec("this.position = {0}".format(this['pos']))
	'''
	
	def setOnUse(this, parent):
		this.worldOrientation = parent.worldOrientation
		if 'pos' in this:
			exec("this.position = {0}".format(this['pos']))
		this.visible = True
		
	def setAsBackUp(this):
		if 'posWhenUnUsed' in this:
			exec("this.position = {0}".format(this['posWhenUnUsed']))
		else:
			this.position = [0,0,0]
		if this.hideWhenUnused == True:
			this.visible = False
			
	def setTipe(this, tipe):
		this.tipe = tipe
		if this.tipe == "linear":
			this.shell = "linear_shell"
		
	def setShootOneByOne(this):
		this.shootOneByOne = True
		this.unShootBarels = this.barels
						
	def checkFire(this, tembak):
		now = datetime.datetime.now()
		jarak = now - this.lastTimeOfFire
		
		if tembak == 2:
			#print("trying to fire weapon {0} with time a : {1} and time b : {2}".format(this.name, str(jarak.seconds), str(this.reloadTime)))
			#if this.mag > -1:
			if this.ammo > 0:
				interval = rTimeLeft(jarak, this.interval)
				if interval <= 0:
					this['fire'] = True
					if this.tipe != "melee":
						if this.shootOneByOne == False:
							for barel in this.barels:
								projectile = this.scene.addObject(this.shell, barel)
								if this.infinityAmmo == False:
									this.ammo -= 1
								projectile.worldOrientation = this.worldOrientation
								projectile.localLinearVelocity = Vector((this.output.x * this.velocity, this.output.y * this.velocity, this.output.z * this.velocity))
								projectile['speed'] = [this.output.x * this.velocity, this.output.y * this.velocity, this.output.z * this.velocity]
								#print('projectile has been shot with speed = {0}'.format(projectile.localLinearVelocity))
								this.lastTimeOfFire = datetime.datetime.now()
								projectile['shootWith'] = this.name
								projectile['scale'] = this.scale
								if this.useBy != None:
									projectile['useBy'] = this.useBy
								if 'timeToLive' in projectile:
									projectile['timeToLive'] = this.timeToLive
					else:
						if this.cont != None:
							pass
							#melee script here
			#sampe sini
		else:
			this['fire'] = False
								
		if this.ammo == 0:
			if this.reloadStatus == "standBy":
				this.reloadStatus = "gonnaReload"
			
		if this.reloadStatus == "awal":
			if this.infinityMag == False:
				if this.mag > 0:
					this.mag -= 1
			this.reloadStatus = "standBy"
		if this.reloadStatus == "gonnaReload":
			this.lastTimeOfFire = datetime.datetime.now()
			jarak = now - this.lastTimeOfFire
			this.reloadTimeLeft = rTimeLeft(jarak, this.reloadTime)
			this.reloadStatus = "isReloading"
		if this.reloadStatus == "isReloading":
			jarak = now - this.lastTimeOfFire
			this.reloadTimeLeft = rTimeLeft(jarak, this.reloadTime)
			if this.reloadTimeLeft <= 0.0:
				this.reloadStatus ="reloaded"
		if this.reloadStatus == "reloaded":
			if this.mag > 0:
				if this.infinityMag == False:
					this.mag -= 1
				this.ammo = this.ammoSize
			if this.mag == 0 and this.ammo == 0:
				this.reloadStatus = "abis"
			else:
				this.reloadStatus = "standBy"